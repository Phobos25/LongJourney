# Tensor Flow

Tensor Flow это открытая библиотека для работы с deep learning. 

# Computer vision
Для компьютера изображение выглядит как 2D матрица из чисел от 0 до 255. Это для чернобелых изображений. Для цветных будет 3D матрица с глубиной 3 (RGB). Для обучения нашего алгоритма используется так называемый convolution --- это матрица, которая ищет определенные паттерны в нашем рисунке. Нам самим его задавать не надо, модель сама должна подобрать. 
Пример convolution:
```
 1.5  1.5
-1.5 -1.5
```
Такая матрица ведет поиск горизонтальной линии на рисунке. Для горизонтальной линии эта матрица будет давать значение намного выше 0, а для вертикальных или если линия вообще отсутствует будет давать значение ближе к 0. 

После создания фильтра мы получаем выходной тензор, в котором выделены нужные нам паттерны. Каждый слой выходного тензора результат одного фильтра, мы можем использовать очень много фильтров, чтобы найти более сложные паттерны. Многие современные модели содержат тысячи фильтров и способны найти очень интересные паттерны, машины, пешеходов, светофоры и т.д.

# Дообучение моделей
В туториалах и практических занатиях во время обучения часто используют веса уже обученных моделей. Такой подход понятен, т.к. обучать модели очень долго, но когда студенты хотят применить модели к задачам классификации немного другого характера, например, если хотят разделить фотографии на городские и лесные, модели не будут работать. Т.к. модели не классифицировали на такие специфические задачи. Можно, конечно, поискать готовые обученные модели такие, либо самому обучить модель, но для этого надо тысячи вручную классифицированных фотографий. В такие моменты используется, т.н. **дообучение**. Видите ли, модель состоит из множества слоев, и нижние слои ищут очень простые закономерности --- вертикальные линии, горизонтальные линии, изменение цветов и т.п., и только более верхние начинают искать более сложные закономерности, т.е. используется более сложные фильтры больших размеров. И только самый последний слой классифицирует рисунки. Поэтому для нашей задачи, мы выбросим самый последний слой и заменим на свою, новую классификацию. Для этого нам надо классифицировать фотографии на предмет, насколько они городские, и насколько они лесные. 

В классификациях с двумя классами часто возникает желание классифицировать только на 1 класс, а если не подходит к первому классу, фотография автоматически относится ко второму. Ни в коем случае так не делайте, т.к. в будущем, если понадобится добавить еще один класс, вам придется все делать заново и, вероятно, полностью менять логику/алгоритм вашей модели. С точки зрения повторного применения кода и объектно-ориентированного программирования это неправильно. Если вы разделите на два класса, то при добавлении третьего, вам не придется менять предыдущие два класса, а просто добавить третий класс. Говоря по простому вы снижаете свою будущую работу на 30%, или будете использовать в будущем 50-70% вашего кода. 

Рассмотрим на примере кода:
```
from tensorflow.python.keras.models import Sequential
from tensorflow.python.kreas.layers import Dense

weights_path = '../input/resnet50/resnet50_weights,tf_dim_ordering_tf_kernels_notop...'
num_classes = 2

my_new_model = Sequential()
my_new_model.add(ResNet50 (include_top=False,
                           weights=weights_path,
                           pooling='avg'))
my_new_model.add(Dense(num_classes, activation='softmax'))

my_new_model.layers[0].trainable = False
```

"include_top=False" --- означает, что мы убираем последний слой, который классифицировал данные

"my_new_model.layers[0].trainable = False" --- указывает, что не надо обучать загруженный слой, т.к. мы используем уже обученную модель, обучать ее заново нам не надо. 

Начало рабоыт с практикой

# Data Augmentation







