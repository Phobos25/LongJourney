# Коллаборативная фильтрация

Коллаборативная фильтрация используется в проблемах ранжирования вообще и текстовых поисках в частности. 

**Определения и обозначения:**

U --- множество субъектов (users/пользователей/клиентов)
I --- множество объектов (items/предметов/товаров/ресурсов)
Y --- пространство описаний транзакций;
Эти субъекты/пользователи/клиенты пользуются объектами/предметами/товарами/ресурсами и каждая такая транзакция откладывается в базе транзакционных данных D и описывается каким-то Y. 

$$D = (u_t, i_t, y_t)^{m}_{t=1} \in U \times I \times Y$$ --- транзакционные данные;

Для работы не очень важно, что из себя представляет Y, и сразу пытаться его описать не всегда эффективно. Обычно эти тройки данных сразу представляют в виде матрицы (матрица кросс-табуляции).  

**Агрегированные данные:**
$$R=||r_{ui}||$$ --- матрица кросс-табуляции размера $$|U|\times |I|$$;
где $$r_{ui}=aggr\{(u_t, i_t, y_t)\in D | u_t = u, i_t = i \}$$

**Задачи**:
* прогнозирование незаполненных ячеек $$r_{ui}$$;
* оценивание сходства: $$\rho(u,u'), \rho(i,i'), \rho(u,i)$$;
* формирование списка рекомендаций для u или для i
 
Пример:
пусть у нас есть, на котором мы продаем какие-нибудь товары. Пусть заходит пользователь, который уже что-то покупал и нам надо, сначала, найти его u (user) в матрице и рекомендовать ему товары отранживаронные по матрице R --- которая отражает насколько товар i  подходит для пользователя u. 

см. пример 1 и 2. 

пример 4 (см. рисунок). Для анализа текстов тоже, получается матрица кросс-табуляций и математика в этих задачах одна и та же. Проблема с коллаборативной фильтрацией одна и та же. Взаимодействие между двумя множествами: матрица users - items (матрица получится сильно разреженной, т.к. не везде есть заполненная информация), двудольный граф (есть два типа объектов и некоторые из них соединены ребрами). В случае текстов --- у нас получается два множества объектов: множество документов и множество слов. 

Существует два основных подхода в коллаборативной фильтрации:
**Корреляционные модели** и **Латентные модели**
Первый несмотря на то, что имеет много недостатков и был из-за чего неоднократно обруган все еще используется из-за своей простоты:
# Memory-Based Collaborative Filtering
* хранение всей исходной матрицы данных R
* сходство клиентов --- корреляция строк матрицы R
* сходство объектов --- корреляция столбцов матрицы R

Вторая модель пытается найти, сначала, какие-то векторные описания объектов и клиентов, а затем оперируя этими векторами искать какие-то закономерности и сходства:
# Latent Models for Collaborative Filtering
* оценивание профилей клиентов и объектов (профиль --- это вектор скрытых характеристик)
* хранение профилей вместо хранения R
* сходство клиентов и объектов --- сходство их профилей

Чтобы понять как надо делать, надо сначала понять как не надо делать. Рассмотрим тривиальную рекомендательную систему, которая впервые была использована в Amazon.com. "*клиенты купившие книгу ($$i_0$$), также покупали ($$I(i_0)$$) [список предметов]*"

Мы имеем страницу на которую зашел наш пользователь (книга в нашем случае) и записываем. В нашей модели пользователь будет строкой в матрицей а книга будет столбцом. Затем мы просто ищем по столбцам какие пользователи еще покупали данную книгу, и также, смотрим что еще они купили и рекомендуем его нашему пользователю. 

**Недостатки:**
* рекомендации тривиальны, т.к. мы будем всем рекомендовать прочитать Гарри Поттера (предлагается наиболее популярное);
* не учитываем (слабо учитываем) интересы пользователя;
* проблема "холодного старта". *Если ест книга, которую еще никто не купил, то ее мы не будем никому рекомендовать*;
* надо хранить всю матрицу R.

**Немножко улучшенный вариант это идти не от товара, а от клиента (User-based CF).
"клиенты, похожие на $$u_0$$ (на тебя), также покупали такие книги I($$u_0$$)".**

Теперь мы ищем пользователей, которые похожи на нашего пользователя (заходили на те же страницы и жанры книг). используется следующая формула:
$$U(u_0):=\{u \in U |sim(u_0,u)> \alpha|\}$$ --- коллаборация; $$sim(u_0,u)$$ --- одна из возможных мер близости u к $$u_0$$.
Дальше используется мера сходства, сортируем наши книги по сходству и рекомендуем нашему пользователю. 

**Недостатки:**
* ~~рекомендации тривиальны~~;
* ~~не учитываем (слабо учитываем) интересы пользователя;~~
* проблема "холодного старта". *Если ест книга, которую еще никто не купил, то ее мы не будем никому рекомендовать*;
* надо хранить всю матрицу R;
* **нечего рекомендовать нетипичным/новым пользователям.**

**Еще один вариант идти от объекта (item-based CF)**. "вместе с объектами, которые покупал $$u_0$$, часто покупают I($$u_0$$)". 

**Недостатки:**
* рекомендации часто тривиальны;
* проблема "холодного старта". *Если ест книга, которую еще никто не купил, то ее мы не будем никому рекомендовать*;
* надо хранить всю матрицу R;
* ~~нечего рекомендовать нетипичным/новым пользователям.~~

# восстановление пропущенных значений (рейтингов)
Данный метод используется для того, чтобы исходя из уже существующих рейтингов юзера, предсказать, как он оценит другие фильмы --- которые он еще не посмотрел, или не оценил. 

Для этого используется непараметрическая регрессия Надарая-Ватсона (формула ядерного сглаживания):

$$\hat{r}_{ui} = \tilde{r}_{u} + \frac{\sum_{u' \in U_{\alpha}(u)}sim(u,u')(r_{u'i - \tilde{r}_{u'}})}{\sum_{u' \in U_{\alpha}(u)}sim(u,u')}$$

где $$\tilde{r}_u = \frac{1}{|I(u)|}\sum_{i\in I(u)}r_{ui}$$ --- средний рейтинг клиента u. 
I(u) --- множество объектов, которые клиент u оценил,
sim(u,u') --- сглаживающее ядро, функция близости u и u'
$$U_\alpha(u)={\ u' |sim(u',u)>\alpha}\}$$

Мы используем средний рейтинг, т.к. даже если рейтинг ограничен с 1 до 5, разные юзеры очень по разному относятся к рейтингу. Некоторые ставят 5 хорошему фильмы, 4 плохому фильмы. Другие ставят 1 плохому фильмы, 2 хорошему фильмы, т.к. у них очень высокая планка. Третьи ставят 5 хорошему фильмы, 1 плохому фильму. Усреднение делается для того, чтобы сгладить эти разные подходы. 

**Недостатки:**
* проблема "холодного старта";
* надо хранить всю матрицу R.

Функции близости используемые в корреляционных методах (см. рис.)

# Резюме

Коллаборативная фильтарция (Collaborative Filtering) --- это набор методов для построения рекомендательных систем (Recommender Systems). 

Латентные модели обладают рядом преимуществ:
* тематические профили содержательно интерпретируемы, могут оцениваться по внешним данным,
* что позволяет решать проблему "холодного старта"
* и строить тематическую кластеризацию (таксономию);
* оценки сходства клиентов и объектов более адекватны;
* резко сокращается объём хранимых данных. 






