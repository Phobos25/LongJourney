## Памятка о типичных ошибках и способах их исправления
collapsed:: true
	- Эта памятка написана, чтобы помочь Вам **самостоятельно находить ошибки в своих запросах**. Если ваш запрос не принимается системой, то возвращайтесь на эту страничку и пройдитесь по всем пунктам:
	  
	  1. Приведите синтаксис запроса к общепринятому:
		- если у вас есть время, стоит изучить руководство по стилю SQL [https://www.sqlstyle.guide/ru/](https://www.sqlstyle.guide/ru/)
		- можете отформатировать ваш запрос с помощью, например, [https://codebeautify.org/sqlformatter](https://codebeautify.org/sqlformatter)
		- в любом случае, информации и примеров в курсе достаточно для того, чтобы писать запросы корректно.
		  
		  2. Проверьте, что ключевые слова, названия столбцов и значения в 
		  ячейках, которые необходимо найти, написаны правильно. Особенно обратите
		  внимание, чтобы в русских названиях столбцов не было английских букв.
		  
		  3. Проверьте, что:
		- количество открывающихся скобок равно количеству закрывающихся;
		- запятые разделяют перечисление столбцов, но не ключевые слова;
		- запросы разделяются точкой с запятой.
		  
		  4. Проверьте, что последовательность команд указана верно (она отличается от последовательности выполнения команд в запросе):
		  
		  ```
		  SELECT 'столбцы или * для выбора всех столбцов; обязательно'
		  
		  FROM 'таблица; обязательно'
		  
		  WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'
		  
		  GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'
		  
		  HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'
		  
		  ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
		  ```
		  
		  5.  Если запрос включает подзапросы, выполните сначала подзапросы и удостоверьтесь, что получаете ожидаемый результат.
		  
		  6. **Прочитайте комментарии под заданием**: большинство трудностей уже обсуждалось не один раз.
-
- Intro to SQL.
	- Основные команды перечислены в 
	  [[SQL_commands_1]] [[SQL_commands_2]]
-
- ## Вложенный запрос
	- Вложенный запрос, возвращающий одно значение
		- вложенный запрос в [[WHERE]] описан  [[SQL_sub_query]] и пример использования в [[SQL_subset_examples]]
		- вложенный запрос после [[SELECT]] описан в [[SQL_Select]]
	- вложенный запрос, возвращающий несколько значений
		- [[SQL_ANY_ALL]]
	- Использование вложенных запросов в [[SQL_INSERT_INTO]]
- ### Оператор WITH
	- оператор [[WITH]]
- ### Оконные функции. Оператор OVER, ORDER BY
	- [[SQL_ORDER_BY]]
	- Оконные функции позволяют получить некоторую дополнительную 
	  информацию о выборке данных .  С помощью оконных функций можно 
	  реализовать вычисления для набора строк, некоторым образом связанных с 
	  текущей строкой. При этом использование оконной функции не группирует 
	  несколько строк в одну, а сохраняет все строки запроса. Синтаксис 
	  оконных функций:
	  ```
	  название_функции(выражение) 
	  OVER (
	        PARTITION BY столбец_1, столбец_2, ... - это окно
	        ORDER BY ... - сортировка 
	        ROWS BETWEEN - границы окна
	          ...
	  )
	  ```
	- Причем все разделы **OVER **являются не 
	  обязательными, но обязательно нужно указать либо окно, либо сортировку. 
	  На данном шаге рассмотрим самый простой синтаксис оконного выражения:
	- ```
	  название_функции(выражение) 
	  OVER (
	        ORDER BY ...
	  )
	  ```
	  Такое оконное выражение позволяет выполнять одинаковые действия над 
	  всеми записями таблицы (здесь окно - вся таблица). В качестве функций 
	  можно использовать:
	  **ROW_NUMBER() **- просто нумерация строк;
	  **RANK() **- ранжирование строк - при одинаковом значении строкам присваивается один номер, с пропуском номеров;
	  **DENSE_RANK()** - ранжирование строк без пропуска номеров;
	  **LAG()** - выбирает строку, предшествующую текущей, если таковой нет - выдается **NULL**;
	  **LEAD() **- выбирает строку, следующую за текущей, если таковой нет - выдается **NULL**.
	- ### Пример 1
	  collapsed:: true
		- Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов.
		- Запрос
			- ```SQL
			  SELECT student_name, count(DISTINCT step_id) AS Kоличество,
			  - ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер
			  - FROM student INNER JOIN step_student USING (student_id)
			  WHERE result = "correct"
			  GROUP BY student_name
			  ```
		- *Результат:*
			- ```SQL
			  Query result:
			  +--------------+------------+-------+
			  | student_name | Kоличество | Номер |
			  +--------------+------------+-------+
			  | student_60   | 32         | 1     |
			  | student_15   | 30         | 2     |
			  | student_18   | 30         | 3     |
			  | student_27   | 30         | 4     |
			  | student_30   | 30         | 5     |
			  | student_31   | 30         | 6     |
			  | student_36   | 30         | 7     |
			                ...
			  | student_5    | 9          | 61    |
			  | student_63   | 9          | 62    |
			  | student_29   | 8          | 63    |
			  | student_47   | 8          | 64    |
			  +--------------+------------+-------+
			  Affected rows: 64
			  ```
		- В этом запросе после того, как были выбраны все студенты, 
		  посчитаны их шаги с правильными ответами, с помощью оконной функции была
		  выполнена сортировка по количеству верных шагов (**count(DISTINCT step_id)**)  и пронумерованы строки (функция **ROW_NUMBER()**).
		- Дополнительно ранжируем студентов.
		- *Запрос:*
			- ```SQL
			  SELECT student_name, count(DISTINCT step_id) AS Kоличество,
			  
			      ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер,
			  
			      RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Ранг,
			      DENSE_RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Рейтинг
			  
			  FROM student INNER JOIN step_student USING (student_id)
			  WHERE result = "correct"
			  GROUP BY student_name
			  ```
		- *Результат:*
			- ```
			  +--------------+------------+-------+------+---------+
			  | student_name | Kоличество | Номер | Ранг | Рейтинг |
			  +--------------+------------+-------+------+---------+
			  | student_60   | 32         | 1     | 1    | 1       |
			  | student_15   | 30         | 2     | 2    | 2       |
			  | student_18   | 30         | 3     | 2    | 2       |
			  | student_27   | 30         | 4     | 2    | 2       |
			  | student_30   | 30         | 5     | 2    | 2       |
			  | student_31   | 30         | 6     | 2    | 2       |
			  | student_36   | 30         | 7     | 2    | 2       |
			  | student_39   | 30         | 8     | 2    | 2       |
			  | student_4    | 30         | 9     | 2    | 2       |
			  | student_43   | 30         | 10    | 2    | 2       |
			  | student_44   | 30         | 11    | 2    | 2       |
			  | student_46   | 30         | 12    | 2    | 2       |
			  | student_49   | 30         | 13    | 2    | 2       |
			  | student_51   | 30         | 14    | 2    | 2       |
			  | student_53   | 30         | 15    | 2    | 2       |
			  | student_59   | 29         | 16    | 16   | 3       |
			  | student_9    | 29         | 17    | 16   | 3       |
			  | student_23   | 28         | 18    | 18   | 4       |
			  | student_50   | 27         | 19    | 19   | 5       |
			                        ...
			  | student_5    | 9          | 61    | 60   | 15      |
			  | student_63   | 9          | 62    | 60   | 15      |
			  | student_29   | 8          | 63    | 63   | 16      |
			  | student_47   | 8          | 64    | 63   | 16      |
			  +--------------+------------+-------+------+---------+
			  Affected rows: 64
			  ```
		- С помощью функции **RANK()** и** DENSE_RANK()** все
		  студенты, имеющие 30  верно пройденных шагов, получили ранг 2 
		  и  рейтинг 2. Студентам с 29 балами присвоен ранг 16 и  рейтинг 3.
	- ### Пример 2
	  collapsed:: true
		- Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент.
		- Запрос
			- ```SQL
			  SELECT student_name, count(DISTINCT step_id) AS Количество,
			  
			         LAG(count(DISTINCT step_id)) 
			         OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id) AS Разница
			  
			  FROM student INNER JOIN step_student USING (student_id)
			  WHERE result = "correct"
			  GROUP BY student_name
			  ```
		- *Результат:*
			- ```
			  +--------------+------------+---------+
			  | student_name | Количество | Разница |
			  +--------------+------------+---------+
			  | student_60   | 32         | None    |
			  | student_15   | 30         | 2       |
			  | student_18   | 30         | 0       |
			  | student_27   | 30         | 0       |
			  | student_30   | 30         | 0       |
			  | student_31   | 30         | 0       |
			  | student_36   | 30         | 0       |
			  
			  | student_63   | 9          | 0       |
			  | student_29   | 8          | 1       |
			  | student_47   | 8          | 0       |
			  +--------------+------------+---------+
			  Affected rows: 64
			  ```
		- Так как у первой записи нет предыдущей - значение разницы **NULL**. Заменим ее на 0 с помощью функции:
		- ```
		  IFNULL(выражение, результат)
		  ```
		- которая возвращает результат, если выражение равно **NULL**, и само выражение в противном случае.
		- Запрос
			- ```SQL
			  SELECT student_name, count(DISTINCT step_id) AS Количество,
			  
			         IFNULL(LAG(count(DISTINCT step_id)) 
			                OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id), 
			                0) AS Разница
			  
			  FROM student INNER JOIN step_student USING (student_id)
			  WHERE result = "correct"
			  GROUP BY student_name
			  ```
		- Результат
			- ```SQL
			  +--------------+------------+---------+
			  | student_name | Количество | Разница |
			  +--------------+------------+---------+
			  | student_60   | 32         | 0       |
			  | student_15   | 30         | 2       |
			  | student_18   | 30         | 0       |
			  | student_27   | 30         | 0       |
			  | student_30   | 30         | 0       |
			  | student_31   | 30         | 0       |
			  | student_36   | 30         | 0       |
			                ...
			  | student_63   | 9          | 0       |
			  | student_29   | 8          | 1       |
			  | student_47   | 8          | 0       |
			  +--------------+------------+---------+
			  Affected rows: 64
			  ```
		-
	- ### Задание
	-